{"ast":null,"code":"var _classCallCheck = require(\"/Users/larisacapatina/Desktop/Coding/Unit_48/react-jobly/my-app-name/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Users/larisacapatina/Desktop/Coding/Unit_48/react-jobly/my-app-name/node_modules/@babel/runtime/helpers/createClass\");\nvar ANY = Symbol('SemVer ANY');\n// hoisted class for cyclic dependency\nvar Comparator = /*#__PURE__*/function () {\n  \"use strict\";\n\n  _createClass(Comparator, null, [{\n    key: \"ANY\",\n    get: function get() {\n      return ANY;\n    }\n  }]);\n  function Comparator(comp, options) {\n    _classCallCheck(this, Comparator);\n    options = parseOptions(options);\n    if (comp instanceof Comparator) {\n      if (comp.loose === !!options.loose) {\n        return comp;\n      } else {\n        comp = comp.value;\n      }\n    }\n    comp = comp.trim().split(/\\s+/).join(' ');\n    debug('comparator', comp, options);\n    this.options = options;\n    this.loose = !!options.loose;\n    this.parse(comp);\n    if (this.semver === ANY) {\n      this.value = '';\n    } else {\n      this.value = this.operator + this.semver.version;\n    }\n    debug('comp', this);\n  }\n  _createClass(Comparator, [{\n    key: \"parse\",\n    value: function parse(comp) {\n      var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];\n      var m = comp.match(r);\n      if (!m) {\n        throw new TypeError(\"Invalid comparator: \".concat(comp));\n      }\n      this.operator = m[1] !== undefined ? m[1] : '';\n      if (this.operator === '=') {\n        this.operator = '';\n      }\n\n      // if it literally is just '>' or '' then allow anything.\n      if (!m[2]) {\n        this.semver = ANY;\n      } else {\n        this.semver = new SemVer(m[2], this.options.loose);\n      }\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.value;\n    }\n  }, {\n    key: \"test\",\n    value: function test(version) {\n      debug('Comparator.test', version, this.options.loose);\n      if (this.semver === ANY || version === ANY) {\n        return true;\n      }\n      if (typeof version === 'string') {\n        try {\n          version = new SemVer(version, this.options);\n        } catch (er) {\n          return false;\n        }\n      }\n      return cmp(version, this.operator, this.semver, this.options);\n    }\n  }, {\n    key: \"intersects\",\n    value: function intersects(comp, options) {\n      if (!(comp instanceof Comparator)) {\n        throw new TypeError('a Comparator is required');\n      }\n      if (this.operator === '') {\n        if (this.value === '') {\n          return true;\n        }\n        return new Range(comp.value, options).test(this.value);\n      } else if (comp.operator === '') {\n        if (comp.value === '') {\n          return true;\n        }\n        return new Range(this.value, options).test(comp.semver);\n      }\n      options = parseOptions(options);\n\n      // Special cases where nothing can possibly be lower\n      if (options.includePrerelease && (this.value === '<0.0.0-0' || comp.value === '<0.0.0-0')) {\n        return false;\n      }\n      if (!options.includePrerelease && (this.value.startsWith('<0.0.0') || comp.value.startsWith('<0.0.0'))) {\n        return false;\n      }\n\n      // Same direction increasing (> or >=)\n      if (this.operator.startsWith('>') && comp.operator.startsWith('>')) {\n        return true;\n      }\n      // Same direction decreasing (< or <=)\n      if (this.operator.startsWith('<') && comp.operator.startsWith('<')) {\n        return true;\n      }\n      // same SemVer and both sides are inclusive (<= or >=)\n      if (this.semver.version === comp.semver.version && this.operator.includes('=') && comp.operator.includes('=')) {\n        return true;\n      }\n      // opposite directions less than\n      if (cmp(this.semver, '<', comp.semver, options) && this.operator.startsWith('>') && comp.operator.startsWith('<')) {\n        return true;\n      }\n      // opposite directions greater than\n      if (cmp(this.semver, '>', comp.semver, options) && this.operator.startsWith('<') && comp.operator.startsWith('>')) {\n        return true;\n      }\n      return false;\n    }\n  }]);\n  return Comparator;\n}();\nmodule.exports = Comparator;\nvar parseOptions = require('../internal/parse-options');\nvar _require = require('../internal/re'),\n  re = _require.safeRe,\n  t = _require.t;\nvar cmp = require('../functions/cmp');\nvar debug = require('../internal/debug');\nvar SemVer = require('./semver');\nvar Range = require('./range');","map":null,"metadata":{},"sourceType":"script"}